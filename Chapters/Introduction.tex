
\chapter{Introduction}

Constraint Satisfaction Problems (CSPs) represent a common category of NP-complete combinatorial issues within Artificial Intelligence, involving a collection of variables and constraints that establish how these variables interact. The main goal of this thesis is the development of a CSP solver entirely from scratch.

In \cref{chap:CSP} we will discuss how we can write down CSPs in both a formal way and in way that is useful for solvers. For the latter we will be using MiniZinc~\cite{minizinc:2007}, a CSP modeling language developed at and by Monash University in Australia. MiniZinc comes with tools for users that want to solve CSPs, and tools for solvers as well. The main idea of MiniZinc is to be translated to a simpler language called FlatZinc that solvers are able to use directly. MiniZinc is only the language and does not provide a solver. MiniZinc problems are independent from solvers and make it really easy to give the same problem to multiple solvers. At the end of this chapter we will showcase an example problem domain called 8-Queens Problem as an easy to understand CSP that will also be used for benchmarking the solver later.

Afterwards in \cref{chap:solveCSP} we will explore how we can actually solve CSPs. We will start from a naive backtracking algorithm approach that resembles depth first search. Next we will improve on this algorithm by changing which variables the solver tries out first. This is called variable ordering. In a last step we will introduce a method to enhance solving CSPs by using inference. Inference is a way to tighten the problem size and reduce the amount of search we have to do with backtracking. To apply inference there will be two methods discussed: Forward checking and enforcing arc consistency. The former being a simpler approach that is a special case of enforcing arc consistency. The latter can be done in multiple ways, we will be discussing the algorithms called AC-1 and AC-3.

Furthermore in \cref{chap:impl} we introduce our new CSP solver called Oxiflex written from scratch in Rust. Rust~\cite{rust:2014} is a general purpose programming language focused on security and, importantly for Oxiflex, performance. Oxiflex supports a subset of FlatZinc builtin constrains. Builtin constraints are a type of constraint that has to be supported by any solver in order to support FlatZinc and in turn MiniZinc. The architecture of Oxiflex is made up of tree parts: parser, model and solver. Building a solver from scratch has the additional benefit that we can build it in a way so that we can provide flags to turn on each improvement for the algorithm separately. This structure will allow us then in a next step to measure each algorithm combination by its own.

We then proceed in \cref{chap:result} to conduct experiments with Oxiflex. There are two problem domains used: N-Queens (introduced in \cref{chap:CSP}) and Slow Convergence which is a problem from the MinZinc benchmarks repository~\cite{minizinc_slow:2018}. The improvements to the solver algorithm discussed in \cref{chap:solveCSP} will be compared to each other and visualized using diagrams. Both time and and number of iterations are part of the measurements. Time is great to showcase how fast the solving is for the user and iterations is great to see how much we tightened the problem size after each inference step. As we will see those can vary a lot. Results will show that arc consistency enforcing algorithms in Oxiflex do not outperform forward checking or even the naive approach of the algorithm in time measurements. However, they do decrease iterations significantly. We will also see that variable ordering improves the N-Queens problem solving by a lot and even enables Oxiflex to solve the Slow Convergence problem at all.

Finally in \cref{chap:conclusion} we will finish with a discussion of the thesis.

