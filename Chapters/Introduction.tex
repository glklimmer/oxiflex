
\chapter{Introduction}

Constraint Satisfaction Problems (CSPs) are typical NP-complete combinatorial problems in the field of Artificial Intelligence, characterized by a set of variables and constraints that define the relationships between these variables. Our main goal of this thesis is the development of a CSP solver entirely from scratch.

In \cref{chap:CSP} we will discuss how we can write down CSPs in both a formal and an useful way. For the latter we will be using MiniZinc~\cite{minizinc:2007}, a CSP modeling language developed at and by Monash University in Australia. MiniZinc is a toolchain with tools for users that want to solve CSPs and tools for solvers. The main idea of MiniZinc is to translate to a simpler language called FlatZinc that solvers are able to use to solve the problem. MiniZinc is only the language and does not provide a solver. This makes a MiniZinc problem independent from the solver and makes it really easy to give the same problem to multiple solvers. At the of this chapter we will showcase an example problem domain called N-Queens as an easy to understand CSP that will also be used for benchmarking the solver.

In \cref{chap:solveCSP} we will explore how we can actually solve CSPs. We will start from a naive backtracking algorithm approach that resembles depth first search. Next we will improve on this algorithm by changing which variables the solver tries out first. This is called variable ordering. In a last step we will introduce a method to enhance solving CSPs by using inference. Inference is a way to tighten the problem size and reduce the amount of search we have to do with backtracking. To apply inference there will be two methods discussed: Forward checking and enforcing arc consistency. The former beeing a simpler approach that is a special case of enforcing arc consistency. The latter can be done in multiple ways, we will be discussing the algorithms called AC-1 and AC-3.

In \cref{chap:impl} as part of this thesis we introduce a CSP solver called Oxiflex written from scratch in rust. Rust~\cite{rust:2014} is a general purpose programming language focused on security and, importantly for Oxiflex, performance. Oxiflex supports a subset of FlatZinc builtin constrains. Builtin constraints are a type of constraint that has to be supported by any solver in order to support FlatZinc and in turn MiniZinc. The architecture of Oxiflex is made up of tree parts: parser, model and solver. Building a solver from scratch will enable us to build it in a way so that we can build in flags to turn on each improvement for the algorithm separately. This structure will allow us to measure each algorithm combination by its own. This chapter will also explore attempts that were made to make Oxiflex computationally faster by changing used datastructures.

In \cref{chap:result} we will include various experiments done with Oxiflex. There are two problem domains used: N-Queens (introduced in \cref{chap:CSP}) and Slow Convergence which is a problem from the MinZinc benchmarks repository~\cite{minizinc_slow:2018}. The improvments to the solver algorithm discussed in \cref{chap:solveCSP} will be compared to each other and visualized using diagrams. Both time and and number of iterations are part of the measurements. Time is great to showcase how fast the solving is for the user and iterations is great to see how much we thightened the problem size after each inference step. As we will see those can vary a lot. Results will show that arc consistency enforcing algorithms in Oxiflex do not outperform forward checking or even the naive approach of the algorithm in time measurements. However they do decrease iterations significantly. We will also see that variable ordering improves the N-Queens problem solving by a lot and even enables Oxiflex to solve the Slow Convergence problem at all.

In \cref{chap:conclusion} we will finish by a discussion of the thesis and explore possibilities for future work.

