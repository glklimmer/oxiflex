\chapter{Oxiflex}

As part of this thesis we present \textbf{oxiflex}, a minimal constraint satisfaction problem solver from scratch for MiniZinc written in Rust. Oxiflex is a FlatZinc solver that can be used as an backend to MiniZinc. This means oxiflex minimally supports the requirements for a solver to take advantage of the MiniZinc toolchain. The goal is to have a minimal solver and be able measure the impact of various improvements like forward checking on constraint satisfaction problem solvers.

Oxiflex is open-source and licensed under the MIT license. It is available at Github \url{https://github.com/glklimmer/oxiflex}.

\section{Rust}

Rust \cite{rust:2014} is a general purpose systems programming language focused on safety and performance. It achieves these goals without using a garbage collector by ensuring memory safety through a system of ownership with strict compile-time checks enforced by the borrow checker. This makes Rust particularly well-suited for creating performance-critical applications like CSP solvers where control over resources is crucial. This makes Rust an ideal choice for developing oxiflex.

\section{Dependecies}

This work depends on previous work by others. This section highlights the components used by oxiflex.

\subsection{flatzinc} \label{flatzinc}

The library flatzinc~\cite{flatzinc:2020} is a FlatZinc parser for Rust. It parses the FlatZinc format into Rust structures and variables.

\subsection{structopt}

The library structopt~\cite{structopt:2020} is utilized to parse command-line arguments in oxiflex. This library simplifies setting up custom commands and options for oxiflex.

\subsection{hyperfine}

The librabry hyperfine~\cite{hyperfine:2023} is a command-line benchmarking tool. We use hyperfine to measure and compare the performance of different solver strategies and optimizations.

\section{Architecture}

There are three main parts of oxiflex.

\begin{itemize}
	\item parser
	\item model
	\item solver
\end{itemize}

\subsection{parser}

Using the library flatzinc \ref{flatzinc} oxiflex reads an FlatZinc \verb|.fzn| file and collects all parts needed to then construct a constraint satisfaction network. These include a list for parameters, variables and constraints. In order to also output the solution after solving the problem, MiniZinc makes use of annonations on FlatZinc elements. Variables that are needed for the output are annotated as \verb|output_var|. There are two possible output annotations in FlatZinc: \verb|output_var| and \verb|output_array|.

\subsection{model}

After parsing the FlatZinc file into Rust structures that can be used directly, oxiflex starts to build useful structures  to solve any given problem. This is where oxiflex creates a model containing variables with their respectice domains and constraints. Models use HashMaps to keep track of its variables and their respective domains. This allows for constant access time to domains to either read or modify them after inference (\ref{inference}) for example. Constraints are saved by the model as a list (In rust this is a pointer, capacity, length triplet). Usually when checking if constraints are violated we either want all constraints or all constraints related to a variable. For this reason an additional HashMap is created that uses variable ids as key and points to a list in the heap. In rust this can be done by using reference counting. This results in two ways to access constraints. One that is just a list to iterate over all constraint and a hashmap to get all constraints that use a specific variable.

\subsection{Limitations}

There are some limitations due to time constraints that currently limit oxiflex as a universal MiniZinc solver. \\

Not all FlatZinc builtins are supported. The idea is to implement just the needed builtins for any given insteresting problem domain.
% Maybe add roadmap?

\section{Solver}

The solver is the core part of oxiflex. By allowing control over what optimization is turned on or off we can measure the impact of each optimization individually. As discussed in Chapter \ref{solving_csp}: \nameref{solving_csp}, there are various optimizations for solving CSPs. See the following diagram to see all optimizations implemented in oxiflex. \\

\begin{tikzpicture}[node distance=2cm and 3cm, auto]
	% Styles
	\tikzset{
		abstraction/.style={draw, rectangle, fill=red!20, text width=10em, text centered, minimum height=2.5em},
		file/.style={draw, rectangle, fill=blue!20, text width=10em, text centered, minimum height=2.5em},
		method/.style={draw, ellipse, fill=green!20, text width=5em, text centered, minimum height=3em},
		line/.style={draw, -Latex}
	}

	% Nodes
	\node[abstraction] (solver) {Solver};

	\node[file, below left of=solver, node distance=3cm] (naiveBT) {naive\_backtracking.rs};
	\node[file, below right of=solver, node distance=3cm, xshift=2cm] (inferenceSolver) {inference.rs};

	\node[method, below=1cm of naiveBT, xshift=0.5cm] (varOrder1) {Variable Ordering}; % Adjusted further below
	\node[method, below=1cm of inferenceSolver, xshift=-2cm] (forwardCheck) {Forward Checking};
	\node[method, below=1cm of inferenceSolver, xshift=1cm] (arc1) {AC-1};
	\node[method, right=0cm of arc1, yshift=0.7cm] (arc3) {AC-3};

	% Lines
	\path[line] (solver) -- (naiveBT);
	\path[line] (solver) -- (inferenceSolver);
	\path[line] (naiveBT) -- (varOrder1);
	\path[line] (inferenceSolver) -- (varOrder1);
	\path[line] (inferenceSolver) -- (forwardCheck);
	\path[line] (inferenceSolver) -- (arc1);
	\path[line] (inferenceSolver) -- (arc3);

\end{tikzpicture}

By default each optimization in oxiflex is turned on. By passing flags named after each optimization we can disable the respective optimization. The help menu can be printed using \verb|oxiflex --help| from the console.

\begin{verbatim}
FLAGS:
    -f, --forward-checking
    Use forward checking as inference

    -n, --naive-backtracking
    Use naive backtracking, e.g. no forward_checking

    -r, --random-variable-order
    Use random order for variable assignments.

    -a, --arc-consistency <arc-consistency>
    Specify arc consistency version [default: 3]
\end{verbatim}

\subsection{Value Ordering}

Oxiflex is able to use dynamic ordering of variables (not values) during search based on the number of constraints.

\subsection{Forward Checking}

\subsection{Arc Consistency}

