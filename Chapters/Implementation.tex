\chapter{Implementation} \label{chap:impl}

\section{Oxiflex}

As part of this thesis we present \textbf{Oxiflex}, a minimal CSP solver from scratch for MiniZinc written in Rust. Oxiflex is a FlatZinc solver that can be used as an backend to MiniZinc. This means Oxiflex minimally supports the requirements for a solver to take advantage of the MiniZinc tool chain and its language. The goal is to have a minimal solver that is able to measure the impact of our improvements like forward checking and enforcing arc consistency on CSP solving.

Oxiflex is open-source, licensed under the MIT license and available on Github\footnote{\url{https://github.com/glklimmer/oxiflex}}.

\section{Rust}

Rust \cite{rust:2014} is a general purpose systems programming language focused on safety and performance. It achieves these goals without using a garbage collector by ensuring memory safety through a system of ownership with strict compile-time checks enforced by the borrow checker. This makes Rust particularly well-suited for creating performance-critical applications like CSP solvers where control over resources is crucial. This makes Rust an ideal choice for developing Oxiflex.

\subsection{Limitations}

Not all FlatZinc builtins are supported in Oxiflex. The idea is to implement just the needed builtins for any given interesting problem domain. Further are only \verb|int|s supported, no floating point values. With that, there are no optimization solving structures available in Oxiflex to be able to search for an optimal solution instead of just any solution.

\section{Dependencies}

\subsection{flatzinc} \label{flatzinc}

The library flatzinc~\cite{flatzinc:2020} is a FlatZinc parser for Rust. It parses the FlatZinc format into Rust structures and variables. Oxiflex uses version \verb|0.3.20| of flatzinc.

\subsection{structopt}

The library structopt~\cite{structopt:2020} is utilized to parse command-line arguments in Oxiflex. This library simplifies setting up custom commands and flags for Oxiflex. Oxiflex uses version \verb|0.3.26| of structopt.

\section{Architecture}

Oxiflex is made up of three parts: parser, model and solver. The solver part can be fine tuned from outside by using command line flags that enable different solving strategies. The output is printed to standard output in a format given by the MiniZinc tool chain.

\subsection{parser}

Using the library flatzinc Oxiflex reads an FlatZinc \verb|fzn| file and collects all parts needed to then construct a constraint satisfaction network. These include a list for parameters, variables and constraints. In order to also output the solution after solving the problem, Oxiflex has to know which variables it has to output. MiniZinc does this by making use of annotations on FlatZinc elements. Variables that are needed for the output are annotated as \verb|output_var|. There are two possible output annotations in FlatZinc: \verb|output_var| and \verb|output_array|.

\subsection{model} \label{model}

After parsing a FlatZinc file into Rust structures that can be used directly, Oxiflex starts to build useful structures to solve a given CSP. This is where Oxiflex creates a model containing variables with their respective domains and constraints. Models use HashMaps to keep track of its variables and their respective domains. This allows for constant access time to domains to either read or modify them after inference for example. Constraints are saved by the model as a list (In Rust this is a pointer, capacity, length triplet). Usually when checking if constraints are violated we either want all constraints or all constraints related to a variable. For this reason an additional HashMap is created called \verb|constraint_index|, that uses variable ids as keys and points to a list of constraints on the heap. In Rust this can be done by using reference counting. This results in two ways to access constraints. One that is just a list to iterate over all constraints and one where a HashMap is used to get all constraints involved by a specific variable.

Variables all have an id. All variable ids are strings. Oxiflex also uses reference counting to store variable ids. As it is often also needed to pass variable ids around, we can mitigate the cost of calling \verb|clone| on variable ids by using reference counting. Instead of actually cloning variable ids, we just pass a pointer to the variable id needed. With reference counting we can ensure the actual memory for the variable id is freed after all pointers to it have been deleted.

\section{Solver}

The solver is the core part of Oxiflex. By allowing control over what optimization is turned on or off we can measure the impact of each optimization individually. As discussed in \cref{chap:solveCSP} there are various optimizations for solving CSPs. See \cref{fig:solver} for an overview of how the optimizations can turned on. \\

\begin{figure}
	\centering
	\begin{tikzpicture}[node distance=2cm and 3cm, auto]
		% Styles
		\tikzset{
			abstraction/.style={draw, rectangle, fill=red!20, text width=10em, text centered, minimum height=2.5em},
			file/.style={draw, rectangle, fill=blue!20, text width=10em, text centered, minimum height=2.5em},
			method/.style={draw, ellipse, fill=green!20, text width=5em, text centered, minimum height=3em},
			addition/.style={draw, ellipse, fill=yellow!20, text width=5em, text centered, minimum height=3em},
			line/.style={draw, -Latex}
		}

		% Nodes
		\node[abstraction] (solver) {Solver};

		\node[file, below left of=solver, node distance=3cm] (naiveBT) {Naive Backtracking};
		\node[file, below right of=solver, node distance=3cm, xshift=2cm] (inferenceSolver) {Inference};

		\node[addition, below=1cm of naiveBT, xshift=0.5cm] (varOrder1) {Variable Ordering};
		\node[method, below=1cm of inferenceSolver, xshift=-2cm] (forwardCheck) {Forward Checking};
		\node[method, below=1cm of inferenceSolver, xshift=1cm] (arc1) {AC-1};
		\node[method, right=0cm of arc1, yshift=0.7cm] (arc3) {AC-3};

		% Lines
		\path[line] (solver) -- (naiveBT);
		\path[line] (solver) -- (inferenceSolver);
		\path[line, dash pattern=on 4pt off 4pt] (naiveBT) -- (varOrder1);
		\path[line, dash pattern=on 4pt off 4pt] (inferenceSolver) -- (varOrder1);
		\path[line] (inferenceSolver) -- (forwardCheck);
		\path[line] (inferenceSolver) -- (arc1);
		\path[line] (inferenceSolver) -- (arc3);

	\end{tikzpicture}
	\caption{Architecture of the Solver options. Blue: choose one of general solver plans, Yellow: turn on or off, Green: choose one.}
	\label{fig:solver}
\end{figure}

By default each optimization in Oxiflex is turned on. By passing flags named after each optimization we can disable the respective optimization. The help menu can be printed using \verb|oxiflex --help| from the console.

\begin{verbatim}
FLAGS:
    -f, --forward-checking
    Use forward checking as inference

    -n, --naive-backtracking
    Use naive backtracking, e.g. no forward_checking

    -r, --random-variable-order
    Use random order for variable ordering.

    -a, --arc-consistency <arc-consistency>
    Specify arc consistency version [default: 3]
\end{verbatim}

\subsection{Value Ordering}

Oxiflex is able to use dynamic ordering of variables during search based on the number of constraints. Enabled by default, Oxiflex orders variables from most constraints involvement to least for an assignment. So variables that are involved with the most constraints are chosen first to be assigned. This fail early approach to ordering can be used both for NaiveBacktracking and Inference based algorithms. For the calculation for which a variable has the most constraints, we use the HashMap called \verb|constraint_index| mentioned in \cref{model}: \nameref{model}. This gives us a list of constraints that we can count based on number of constraints and then choose the variable with the most.

\subsection{Forward Checking}

Forward checking in Oxiflex works by removing values of domains that are no longer valid for some constraints. Domains in Oxiflex are lists of type \verb|Vec|, which are pointer, capacity and length triplets. The removal of values happens in-place. That is, values within the \verb|Vec| are removed without copying the whole domain. We use the function \verb|retain| for that. It iterates over all values in a \verb|Vec| and only "retains" values that pass the constraint checks. Removing single values from a \verb|Vec| has a complexity of $\mathcal{O}(n)$, but as \verb|retain| iterates over all elements either way, the complexity stays there even when removing multiple elements. Forward checking also uses \verb|constraint_index| mentioned in \cref{model}: \nameref{model} to only get the constraints that are needed instead of checking all constraints.

\subsection{Arc Consistency}

Both AC-1 and AC-3 use the function \verb|revise| which ensures arc consistency in one direction for two variables. The main computational work happens within this function. The role of AC-1 and AC-3 is to arrange the calls to \verb|revise|. Within \verb|revise| we also use the \verb|constraint_index| (See \ref{model}: \nameref{model}) to get only constraints that are involved with the given variable for \verb|revise|.

Checking constraints works by checking a \verb|PartialAssignment|. The actual type for \verb|PartialAssignment| is a HashMap with variable id for keys and assignments of variables as values. Therefore within \verb|revise| the given \verb|PartialAssignment| $\alpha$ is expanded with each combination of values from both variables given to \verb|revise|. That means for each value pair within the two domains, $\alpha$ is expanded with two assignments. The first assignment of the first variable and the second assignment of the second variable.
