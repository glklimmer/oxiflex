\chapter{Oxiflex}

As part of this thesis we present \textbf{oxiflex}, a minimal constraint satisfaction problem solver from scratch for MiniZinc written in Rust. Oxiflex is a FlatZinc solver that can be used as an backend to MiniZinc. This means oxiflex supports the minimal requirements for a solver to take advantage of the MiniZinc toolchain. The idea is to have a minimal solver and excatly measure the impact of various improvments on it like forward checking or arc consistency.

Oxiflex is open-source and available under the MIT license under \url{https://github.com/glklimmer/oxiflex}.

\section{Rust}

% pointer for rust lang, maybe add rust book to references
Rust is a general purpose systems programming language focused on safety and performance. It achieves these goals without using a garbage collector by ensuring memory safety through a system of ownership with strict compile-time checks enforced by the borrow checker. This makes Rust particularly well-suited for creating performance-critical applications like CSP solvers where control over resources is crucial. This makes Rust an ideal choice for developing oxiflex.

\section{Dependecies}

This work depends on previous work by others. This section highlights the components used by oxiflex.

\subsection{flatzinc} \label{flatzinc}

The library flatzinc~\cite{flatzinc:2020} is a FlatZinc parser for Rust. It parses the FlatZinc format into Rust structures and variables.

\subsection{structopt}

The library structopt~\cite{structopt:2020} is utilized to parse command-line arguments in oxiflex. This library simplifies setting up custom commands and options for oxiflex.

\subsection{hyperfine}

The librabry hyperfine~\cite{hyperfine:2023} is a command-line benchmarking tool. We use hyperfine to measure and compare the performance of different solver strategies and optimizations.

\section{Architecture}

There are three main parts of oxiflex.

\begin{itemize}
	\item parser
	\item model
	\item solver
\end{itemize}

\subsection{parser}

Using flatzinc \ref{flatzinc} oxiflex reads an FlatZinc \verb|.fzn| file and collects all parts needed to then construct a constraint satisfaction network. These include a list for parameters, variables and constraints. In order to also output the solution after solving the problem, MiniZinc makes use of annonations on FlatZinc elements. Variables that are needed for the output are annotated as \verb|output_var|. There are two possible output annotations in FlatZinc: \verb|output_var| and \verb|output_array|.

\subsection{model}

After parsing the FlatZinc file into Rust structures that can be used directly, oxiflex starts to build useful structures  to solve any given problem. This is where oxiflex creates a model containing variables with their respectice domains and constraints. Models use HashMaps to keep track of its variables and their respective domains. This allows for constant access time to domains to either read or modify them after inference (\ref{inference}) for example. Constraints are saved by the model as a list (In rust this is a pointer, capacity, length triplet). Usually when checking if constraints are violated we either want all constraints or all constraints related to a variable. For this reason an additional HashMap is created that uses variable ids as key and points to a list in the heap. In rust this can be done by using reference counting. This results in two ways to access constraints. One that is just a list to iterate over all constraint and a hashmap to get all constraints that use a specific variable.

\subsection{Limitations}

There are some limitations due to time constraints that currently limit oxiflex as a universal MiniZinc solver. \\

Only binary constrains are supported. The reason for this is that the theory used to implement oxiflex is based on binary constraints. Therefore it made sense to also just support them at first. \\
% but why? maybe just add it instead.

Not all FlatZinc builtins are supported. The idea is to implement just the needed builtins for any given insteresting problem domain.
% Maybe add roadmap?

\section{Solver}

% take algos from papers instead of lecture notes. Can modify algos for clarity.

\subsection{Naive Backtracking}

\begin{tcolorbox}[title=function NaiveBacktracking)]
	$\langle V, \text{dom}, (R_{uv})\rangle := C$ \\
	\textbf{if} $\alpha$ is inconsistent with $C$: \\
	\textbf{return inconsistent} \\
	\textbf{if} $\alpha$ is a total assignment: \\
	\textbf{return $\alpha$} \\
	select some variable $v$ for which $\alpha$ is not defined \\
	\textbf{for each} $d \in$ dom($v$) in some order: \\
	$\alpha' := \alpha \cup \{v \mapsto d\}$ \\
	$\alpha'' := $ NaiveBacktracking($C$, $\alpha'$) \\
	\textbf{if} $\alpha'' \neq$ \textbf{inconsistent}: \\
	\textbf{return} $\alpha''$ \\
	\textbf{return inconsistent}
\end{tcolorbox}

Input: constraint network $C$ and partial assignment $\alpha$ for $C$. On first invocation of NaiveBacktracking we pass an empty assignment $\alpha = \emptyset$. \\
Result: Total assignment (solution) of $C$ or \textbf{inconsistent}.

This algorithm corresponds to Depth First Search (DFS). It assigns to any variable any value from its domain. Repeating this until either all variables are set and a solution is found or a constraint is violated. Then the algorithm goes back and tries an different value from the domain. This is the \textbf{search} part of an CSP solver. The other part is excluding values from variables based on assignments of other variables.

\section{Inference} \label{inference}

In our simple

\subsection{Forward Checking}

\subsection{Arc Consistency}


