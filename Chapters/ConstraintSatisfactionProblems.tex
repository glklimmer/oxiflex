\chapter{Constraint Satisfaction Problems}

Constraint Satisfaction Problems (CSP) \cite{csp:1987} are mathematical questions defined as a finite set of variables whose value must satisfy a number of constraints or limitations. When solely talking about the problem without the algorithmic finding of a solution, these are called Constraint Networks. CSPs are typical NP-complete combinatorial problems in the field of AI.

\begin{tcolorbox}[title=Example:]
	\begin{multicols}{2}
		\begin{equation*}
			\begin{aligned}
				w & = \{1, 2, 3, 4\} \\
				y & = \{1, 2, 3, 4\} \\
				x & = \{1, 2, 3\}    \\
				z & = \{1, 2, 3\}    \\
			\end{aligned}
		\end{equation*}

		\columnbreak

		\noindent
		\begin{equation*}
			\begin{aligned}
				\textbf{where:} \\
				w = 2 \cdot x   \\
				w < z           \\
				y > z           \\
			\end{aligned}
		\end{equation*}
	\end{multicols}
\end{tcolorbox}

We define variables $w$, $y$, $x$ and $z$. Variables $w$ and $y$ can both have one value from $\{1, 2, 3, 4\}$ and variables $x$ and $z$ can have a value from $\{1, 2, 3\}$. The constraints then restrict which values are valid from their respective domains. Here $w = 2 \cdot x$ restrict the value of $x$ to be double of $w$ for example. If there are no constraints for variables, the constraints are still there but they allow every assignment. These constraints are called trivial constraints and are usually omitted.

In this example we define constraints in a mathmatical notation. There are no formal restrictions on stating constraints neither by their complexity nor by the number of variables involved. To make it easier to reason about, we model constraints as binary constraint sets. Constraints are then sets of valid value pairs for two specific variables. Instead of stating the desired relation between any variables, we list all valid value pair tuples in a set. Constraint $w < z$ then becomes $(R_{wz} = \{(1, 2), (1, 3), (2, 3)\}$ which contains all possible value pairs for the two varaibles $w$ and $z$.

We define Constraint Networks formally:

\begin{tcolorbox}
	A (binary) constraint network is a 3-tuple $C = <V, \text{dom}, (R_{uv})>$ such that:
	\begin{itemize}
		\item $V$ is a non-empty and finite set of variables,
		\item dom is a function that assigns a non-empty and finite domain to each variable $v \in V$, and
		\item $(R_{uv})_{u,v \in V, u \neq v}$ is a family of binary relations (constraints) over $V$ where for all $u \neq v: R_{uv} \subseteq \text{dom}(u) \times \text{dom}(v)$
	\end{itemize}
\end{tcolorbox}

And we define our example formally:

\begin{tcolorbox}
	$C = \langle V, \text{dom}, (R_{uv})\rangle$ with
	\begin{itemize}
		\item variables: \\
		      $V = \{w, x, y, z\}$
		\item domains: \\
		      $\text{dom}(w) = \text{dom}(y) = \{1, 2, 3, 4\}$ \\
		      $\text{dom}(x) = \text{dom}(z) = \{1, 2, 3\}$
		\item constraints: \\
		      $R_{wx} = \{(2, 1), (4, 2)\}$ \\
		      $R_{wz} = \{(1, 2), (1, 3), (2, 3)\}$ \\
		      $R_{yz} = \{(2, 1), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3)\}$ \\
	\end{itemize}
\end{tcolorbox}

The goal in CSP is then to find a Assignment that satisfies all constraints. For this simple example a possible assignment would be $(w \mapsto 2), (x \mapsto 1), (y \mapsto 4), (z \mapsto 3)$.

\section{MiniZinc}

MiniZinc~\cite{minizinc:2007} is a free and open-source constraint modeling language developed at and by Monash University in Australia. It allows us to express Constraint Satisfaction Problems in a mathmatical notation-like way.

\begin{tcolorbox}[title=MiniZinc example]
	var 1..4: w; \\
	var 1..4: y; \\
	var 1..3: x; \\
	var 1..3: z; \\

	constraint w = 2 $\times$ x; \\
	constraint w $<$ z; \\
	constraint y $>$ z; \\

	solve satisfy;
\end{tcolorbox}

MiniZinc is only the language to express a problem domain. Once a problem domain is specified in MiniZinc we can give the problem to multiple solvers to solve them. In this way we can compare the performance of various solvers on the same problem domain. MiniZinc Domain files have the file extension \verb|.mzn|.

MiniZinc also provides a way to parametrize a problem domain. This is a great way to scale a problem space up and see how increasing the problem size affects the solving speed. A great example for this is the Queens Problem (See Section~\ref{sec:queens}). We define the Queens Problem domain once and can then run specific problem instances for different $n$. This makes it really easy to compare the solving speed for the queens problem when $n = 8$, $n = 16$ or $n = 32$. Files where we specify parameters for MiniZinc files are called data files and have the extension \verb|.dzn|. We can than combine \verb|.mzn| files with \verb|.dzn| files to created FlatZinc files.

\subsection{FlatZinc}

FlatZinc is a simpler problem specification language provided by the MiniZinc package. It is designed to be used by solvers directly. MiniZinc files are translated to FlatZinc files in a pre-solving step. FlatZinc files have the file extension \verb|.fzn|.

Translating from MiniZinc to FlatZinc maps more advanced instructions from MiniZinc to primitives supported in FlatZinc. An analogy to this translation is compiling a C program to Assembly where MiniZinc is C and FlatZinc is Assembly. FlatZinc therefore requires solvers to support a set of standard contraints called FlatZinc builtins. Builtins need to be implemented to be a fully compatible FlatZinc solver. See the following for an FlatZinc translation using our simple example.

\begin{tcolorbox}[title=Simple example translated to FlatZinc (Simplified)]
	array [1..2] of int: x\_introduced\_2\_ = [1,-2]; \\
	array [1..2] of int: x\_introduced\_3\_ = [1,-1]; \\
	array [1..2] of int: x\_introduced\_4\_ = [-1,1]; \\
	var 2..4: w:: output\_var; \\
	var 1..4: y:: output\_var; \\
	var 1..3: x:: output\_var; \\
	var 1..3: z:: output\_var; \\
	constraint int\_lin\_eq(x\_introduced\_2\_,[w,x],0); \\
	constraint int\_lin\_le(x\_introduced\_3\_,[w,z],-1); \\
	constraint int\_lin\_le(x\_introduced\_4\_,[y,z],-1); \\
	solve  satisfy;
\end{tcolorbox}

The translation of the variable declations is straight forward. For the constraints, MiniZinc translated all constraints into FlatZinc builtin constraints. For our simple example MiniZinc used two builtins: \verb|int_lin_eq| and \verb|int_lin_le|. See the lines that start with \verb|constraint|. We will look at \verb|int_lin_eq| further to see how FlatZinc builtins work. The following is the signature of the builtin \verb|int_lin_eq| that was used for the constraint $w = 2 \cdot x$.

\begin{tcolorbox}[title=int\_lin\_eq builtin signature]
	predicate int\_lin\_eq(array [int] of int: as,\\
	array [int] of var int: bs,\\
	int: c)
\end{tcolorbox}

Note that the builtin \verb|int_lin_eq| expects 3 parameters. The first \verb|as| is an array of \verb|int| constants. This is what the example FlatZinc translation named \verb|x_introduced_2|. This array is called a parameter, because it has concrete values assigned to it. Here \verb|x_introduced_2| has the value \verb|[1,-2]| assigned. The second parameter \verb|bs| is an array of \verb|int| variables, that is an array of variables that we want to solve for. Here the variables $w$ and $x$ are passed in also as an array \verb|[w,x]|. The third parameter \verb|c| is also a parameter because it is also a constant value that needs to be passed. Here the value for \verb|c| is $0$.

Every FlatZinc builtin also has a description for when the constraint is valid or violated respectively. For \verb|int_lin_eq| the description is as follows.

\begin{tcolorbox}[title=int\_lin\_eq builtin constraint]
	\begin{equation}
		c = \sum_{i} \text{as}[i] \cdot \text{bs}[i]
	\end{equation}
\end{tcolorbox}

For this builtin MiniZinc translated our constraint into a linear combination. With our example we can fill in the passed parameters to the constraint and we get $0 = w - 2x$ which can be rearranged to $w = 2 \cdot x$.

Note that FlatZinc created these parameter arrays by itself. The \verb|x| within \verb|x_introduced_2_| is not the same as our variable $x$ that we defined within MiniZinc.

Also note that for the translation MiniZinc already does some basic level of inference. The FlatZinc variable $w$ can only have values between $2$ and $4$ in the translated FlatZinc. Whereas in the MiniZinc version we defined $w$ with the domain $\{1, 2, 3, 4\}$. This means MiniZinc infers that $w$ can not be value $1$ and removes it from its domain declaration. Due to the constraint $w = 2 \times x$, the variable $w$ has to be double of $x$ and $x$ must have at least value $1$. Therefore excluding $1$ as possible value for $w$.

\section{Queens Problem} \label{sec:queens}

Also called the Eight Queens Puzzle, the Queens Problem is an example of a classic constraint satisfaction problem that involves placing eight queens on an 8x8 chessboard in such a way that no two queens threaten each other. That is, no two queens can share the same row, column, or diagonal. See the following for an example solution to the 8-Queens Problem.

\newchessgame
\chessboard[setfen=1Q6/3Q4/5Q2/7Q/2Q5/Q7/6Q1/4Q3 w - - 0 1, showmover=false] \\

The Eigth Queens Puzzle is really good suited as an example problem domain for constraint satisfaction problems because it is easy to understand and can also easily be scaled up to increase complexity for a solver. By generalizing the problem from a fixed $8 \times 8$ grid size to an $n \times n$ grid with $n$ queens, the problem remains the same in principle, but gets way harder to solve. See the following example of the queens problem modeled in MinZinc \cite{minizinc_queens:2006}.

\begin{tcolorbox}[title=MiniZinc Model for N-Queens Problem]
	int: n; \\

	array [1..n] of var 1..n: q; \\

	predicate \\
	noattack(int: i, int: j, var int: qi, var int: qj) = \\
	qi     != qj     /\textbackslash \\
	qi + i != qj + j /\textbackslash \\
	qi - i != qj - j; \\

	constraint \\
	forall (i in 1..n, j in i+1..n) ( \\
	noattack(i, j, q[i], q[j]) \\
	); \\

	solve satisfy;
\end{tcolorbox}

This MiniZinc model defines an array of variables $q$ where each index corresponds to a column on the chessboard and the value at each index represents the row position of the queen in that column. The constraints ensure that no two queens are on the same row, column or diagonal.

