\chapter{Constraint Satisfaction Problems}

Constraint Satisfaction Problems (CSP) are mathematical questions defined as a finite set of variables whose value must satisfy a number of constraints or limitations. When solely talking about the problem without the algorithmic finding of a solution, these are called Constraint Networks.

\begin{tcolorbox}[title=Example:]
	\begin{multicols}{2}
		\begin{equation*}
			\begin{aligned}
				w & = \{1, 2, 3, 4\} \\
				y & = \{1, 2, 3, 4\} \\
				x & = \{1, 2, 3\}    \\
				z & = \{1, 2, 3\}    \\
			\end{aligned}
		\end{equation*}

		\columnbreak

		\noindent
		\begin{equation*}
			\begin{aligned}
				\textbf{where:} \\
				w = 2*x         \\
				w < z           \\
				y > z           \\
			\end{aligned}
		\end{equation*}
	\end{multicols}
\end{tcolorbox}

We define variables $w$, $y$, $x$ and $z$. Variables $w$ and $y$ can both have one value from $\{1, 2, 3, 4\}$ and variables $x$ and $z$ can have a value from $\{1, 2, 3\}$. The constraints then restrict which values are valid from their respective domains. Here $w = 2 \times x$ restrict the value of $x$ to be double of $w$.

Here we define constraints in a mathmatical notation. There are no formal restrictions on stating constraints, neither by their complexity nor by the number of variables involved. To make it easier to reason about, we model constraints as binary constraint sets. Constraints are sets of valid value pairs for two specific variables. Instead of stating the desired relation between any variables, we list all valid value pair tuples in a set. Constraint $w < z$ becomes $(R_{wz} = \{(1, 2), (1, 3), (2, 3)\}$ which contains all possible value pairs for the two varaibles: $w$ and $z$.

We define Constraint Networks formally:

\begin{tcolorbox}
	A (binary) constraint network is a 3-tuple $C = <V, \text{dom}, (R_{uv})>$ such that:
	\begin{itemize}
		\item $V$ is a non-empty and finite set of variables,
		\item dom is a function that assigns a non-empty and finite domain to each variable $v \in V$, and
		\item $(R_{uv})_{u,v \in V, u \neq v}$ is a family of binary relations (constraints) over $V$ where for all $u \neq v: R_{uv} \subseteq \text{dom}(u) \times \text{dom}(v)$
	\end{itemize}
\end{tcolorbox}

And we define our example formally:

\begin{tcolorbox}
	$C = <V, \text{dom}, (R_{uv})>$ with
	\begin{itemize}
		\item variables: \\
		      $V = \{w, x, y, z\}$
		\item domains: \\
		      $\text{dom}(w) = \text{dom}(y) = \{1, 2, 3, 4\}$ \\
		      $\text{dom}(x) = \text{dom}(z) = \{1, 2, 3\}$
		\item constraints: \\
		      $R_{wx} = \{(2, 1), (4, 2)\}$ \\
		      $R_{wz} = \{(1, 2), (1, 3), (2, 3)\}$ \\
		      $R_{yz} = \{(2, 1), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3)\}$ \\
	\end{itemize}
\end{tcolorbox}

The goal in CSP is then to find a Assignment that satisfies all constraints. For this simple example a possible assignment would be $(w \mapsto 2), (x \mapsto 1), (y \mapsto 4), (z \mapsto 3)$.

\section{MiniZinc}

MiniZinc~\cite{minizinc:2007} is a free and open-source constraint modeling language developed at and by Monash University in Australia. It allows us to express Constraint Satisfaction Problems in a mathmatical notation-like way.

\begin{tcolorbox}[title=MiniZinc example]
	var 1..4: w; \\
	var 1..4: y; \\
	var 1..3: x; \\
	var 1..3: z; \\

	constraint w = 2 $\times$ x; \\
	constraint w $<$ z; \\
	constraint y $>$ z; \\

	solve satisfy;
\end{tcolorbox}

MiniZinc is only the language to express a problem domain. Once a problem domain is specified in MiniZinc we can give the problem to multiple solvers to solve it. Like that we can compare the performance of various solvers on the same problem domain. MiniZinc Domain files have the file extension \verb|.mzn|. \\

MiniZinc also provides a way to parametrize a problem domain. This is a great way to scale the problem space up and see how increasing the problem space affects the solving speed. A great example for this is the Queens Problem (See Section~\ref{sec:queens}). We define the Queens Problem domain once and can then run specific problem instances for different $n$. This makes it really easy to compare $n = 8$, $n = 16$ and $n = 32$ for example.

\subsection{FlatZinc}

FlatZinc is a simpler problem specification language provided by the MiniZinc package. It is designed to be used by solvers directly. MiniZinc files are translated to FlatZinc files in a pre-solving step. FlatZinc files have the file extension \verb|.fzn|.

\begin{tcolorbox}[title=FlatZinc example]
	array [1..2] of int: x\_introduced\_2\_ = [1,-2]; \\
	array [1..2] of int: x\_introduced\_3\_ = [1,-1]; \\
	array [1..2] of int: x\_introduced\_4\_ = [-1,1]; \\
	var 2..4: w:: output\_var:: is\_defined\_var; \\
	var 1..4: y:: output\_var; \\
	var 1..3: x:: output\_var; \\
	var 1..3: z:: output\_var; \\
	constraint int\_lin\_eq(x\_introduced\_2\_,[w,x],0):: defines\_var(w); \\
	constraint int\_lin\_le(x\_introduced\_3\_,[w,z],-1); \\
	constraint int\_lin\_le(x\_introduced\_4\_,[y,z],-1); \\
	solve  satisfy;
\end{tcolorbox}

Translating from MiniZinc to FlatZinc maps more advanced instructions from MiniZinc to primitives supported in FlatZinc. An analogy to this translation is compiling a C program to Assembly where MiniZinc is C and FlatZinc is Assembly. FlatZinc requires solvers to support a set of standard contraints called "FlatZinc builtins" to be implemented to be a fully compatible FlatZinc solver. We only support a minimal set of builtins to enable a selection of domains exactly. \\

Our constraints are split into two parts and translated into linear combinations. Constraint $w = 2 \times x$ is translated to the builtin called \verb|int_lin_eq| which is defined as follows:

\begin{tcolorbox}[title=int\_lin\_eq builtin]
	predicate int\_lin\_eq(array [int] of int: as,\\
	array [int] of var int: bs,\\
	int: c)
\end{tcolorbox}

The constraint \verb|int_lin_eq| constraints those values to this.

\begin{tcolorbox}[title=int\_lin\_eq builtin constraint]
	\begin{equation}
		c = \sum_{i} \text{as}[i] \times \text{bs}[i]
	\end{equation}
\end{tcolorbox}

Note that MiniZinc already does some basic level of inference. The FlatZinc variable $w$ can only have values between $2$ and $4$. This means MiniZinc infers that $w$ can not be value $1$ and removes it from its domain declaration. Due to $w = 2 \times x$ the variable $w$ has to be double of $x$ and $x$ must have at least value $1$ excluding $1$ as possible value for $w$.

\section{Queens Problem} \label{sec:queens}

Also called the Eight Queens Puzzle, the Queens Problem is an example of a classic constraint satisfaction problem that involves placing eight queens on an 8x8 chessboard in such a way that no two queens threaten each other. That is, no two queens can share the same row, column, or diagonal.

\newchessgame
\chessboard[setfen=1Q6/3Q4/5Q2/7Q/2Q5/Q7/6Q1/4Q3 w - - 0 1, showmover=false]

The Eigth Queens Puzzle is really good suited as an example domain for constraint satisfaction problems because it is easy to understand and can also easily be scaled up to increase complexity for a solver. By generalizing the problem from a fixed $8 \times 8$ grid size to an $n \times n$ grid with $n$ queens, the problem remains the same, but gets way harder to solve.

\begin{tcolorbox}[title=MiniZinc Model for N-Queens Problem]
	int: n; \\

	array [1..n] of var 1..n: q; \\

	predicate \\
	noattack(int: i, int: j, var int: qi, var int: qj) = \\
	qi     != qj     /\textbackslash \\
	qi + i != qj + j /\textbackslash \\
	qi - i != qj - j; \\

	constraint \\
	forall (i in 1..n, j in i+1..n) ( \\
	noattack(i, j, q[i], q[j]) \\
	); \\

	solve satisfy;
\end{tcolorbox}

This MiniZinc model defines an array of variables $q$ where each index corresponds to a column on the chessboard and the value at each index represents the row position of the queen in that column. The constraints ensure that no two queens are on the same row, column or diagonal.

