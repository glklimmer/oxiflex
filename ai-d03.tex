% -*- mode: latex; coding: utf-8 -*-

\input{header}

\lectureno{D3}
\subtitle{Constraint Satisfaction Problems: Backtracking}
\date{April 10, 2024}

\usetikzlibrary{automata}
\usetikzlibrary{shapes}
\usetikzlibrary{snakes}

\begin{document}

\begin{frame}{Constraint Satisfaction Problems: Overview}
  \hilite{Chapter overview: constraint satisfaction problems}
  \begin{itemize}
  \item \hilite{D1--D2.} Introduction
  \item \hilite{D3--D5.} Basic Algorithms
    \begin{itemize}
    \item \alert{D3. Backtracking}
    \item \hilite{D4.} Arc Consistency
    \item \hilite{D5.} Path Consistency
    \end{itemize}
  \item \hilite{D6--D7.} Problem Structure
  \end{itemize}
\end{frame}

\section{CSP Algorithms}

\begin{frame}{CSP Algorithms}
  In the following chapters, we consider \alert{algorithms for
    solving} \\ constraint networks.

  \medskip

  \hilite{basic concepts:}
  \begin{itemize}
    \item \hilite{search:} check partial assignments systematically
    \item \hilite{backtracking:} discard inconsistent partial
    assignments
    \item \hilite{inference:} derive equivalent, but tighter
    constraints \\ to reduce the size of the search space
  \end{itemize}

\end{frame}

\section{Naive Backtracking}

\begin{frame}{Naive Backtracking (= Without Inference)}
  \small
  \begin{block}{\textbf{function} $\func{NaiveBacktracking}(\mathcal{C},
      \alpha)$:}
    $\langle V, \dom, (R_{uv})\rangle := \mathcal{C}$

    \smallskip

    \textbf{if} $\alpha$ is inconsistent with $\mathcal{C}$:\\
    \ind\textbf{return} \textbf{inconsistent}

    \smallskip

    \textbf{if} $\alpha$ is a total assignment:\\
    \ind\textbf{return} $\alpha$

    \smallskip

    select \hilite{some variable} $v$ for which $\alpha$ is not
    defined

    \smallskip

    \textbf{for each} $d \in \dom(v)$ \hilite{in some order}:\\
    \ind$\alpha' := \alpha \cup \{v \mapsto d\}$\\
    \ind$\alpha'' := \func{NaiveBacktracking}(\mathcal{C},\alpha')$\\
    \ind\textbf{if} $\alpha'' \neq \textbf{inconsistent}$:\\
    \indtwo\textbf{return} $\alpha''$\\
    \textbf{return} \textbf{inconsistent}
  \end{block}
  \hilite{input:} constraint network $\mathcal{C}$
  and partial assignment $\alpha$ for $\mathcal{C}$ \\
  (first invocation: empty assignment $\alpha = \emptyset$)

  \hilite{result:} solution of $\mathcal{C}$ or \textbf{inconsistent}
\end{frame}

\begin{frame}{Running Example}
  \begin{exampleblock}{Full Formal Model of Running Example}
    $\mathcal{C} = \langle V, \dom, (R_{uv})\rangle$ with
    \begin{itemize}
      \item \hilite{variables:}\\
        $V = \{w,x,y,z\}$
      \item \hilite{domains:}\\
        $\dom(w) = \dom(y) = \{1,2,3,4\}$\\
        $\dom(x) = \dom(z) = \{1,2,3\}$
      \item \hilite{constraints:}\\
        $R_{wx} = \{\tuple{2,1}, \tuple{4,2}\}$\\
        $R_{wz} = \{\tuple{1,2}, \tuple{1,3}, \tuple{2,3}\}$\\
        $R_{yz} = \{\tuple{2,1}, \tuple{3,1}, \tuple{3,2},$\\
        \invisible{$R_{yz} = \{$}$\tuple{4,1}, \tuple{4,2}, \tuple{4,3}\}$
    \end{itemize}
  \end{exampleblock}
\end{frame}

\iftrue %% allow commenting out this slide quickly because it takes
%% forever to compile

%% TODO: It would be good to see the *algorithm* at least
%% a few times to really understand what is going on. One way to
%% address this is to show multiple slides at the same time.

\begin{frame}{Running Example: Search Tree}
   \begin{tikzpicture}[scale=0.8]
     \node[anchor=north west] at (-0.5,0.5) {
       \begin{minipage}{7cm}
         {\small
           \only<1-2,6|handout:1>{$R_{wx} = \{\tuple{2,1}, \tuple{4,2}\}$}%
           \only<3-5|handout:none>{\alert{$R_{wx} = \{\tuple{2,1}, \tuple{4,2}\}$}}%
           \only<7-|handout:none>{$\hilite{R_{wx}} = \{\hilite{\tuple{2,1}}, \tuple{4,2}\}$}\\
           \only<1-8,12,16,20|handout:1>{$R_{wz} = \{\tuple{1,2}, \tuple{1,3}, \tuple{2,3}\}$}%
           \only<9-10,13-14,17-18,21-22|handout:none>{\alert{$R_{wz} = \{\tuple{1,2}, \tuple{1,3}, \tuple{2,3}\}$}}%
           \only<11,15,19,23|handout:none>{$\hilite{R_{wz}} = \{\tuple{1,2}, \tuple{1,3}, \hilite{\tuple{2,3}}\}$}
         }
     \end{minipage}};

     \node[anchor=north west] at (7,0.5) {
      \begin{minipage}{7cm}
        {\small
        \only<1-8,12,16,20|handout:1>{$R_{yz} = \{\tuple{2,1}, \tuple{3,1}, \tuple{3,2},$}%
        \only<9-11,14-15,19|handout:none>{\alert{$R_{yz} = \{\tuple{2,1}, \tuple{3,1}, \tuple{3,2},$}}%
        \only<13|handout:none>{$\hilite{R_{yz}} = \{\hilite{\tuple{2,1}}, \tuple{3,1}, \tuple{3,2},$}
        \only<17-18,21-22|handout:none>{$\hilite{R_{yz}} = \{\tuple{2,1}, \hilite<17|handout:none>{\tuple{3,1}}, \hilite<18|handout:none>{\tuple{3,2}},$}
        \only<23|handout:none>{$\hilite{R_{yz}} = \{\tuple{2,1}, \tuple{3,1}, \tuple{3,2},$}%
        \\\invisible{$R_{yz} = \{$}%
        \only<1-8,12-13,16-18,20-22|handout:1>{$\hilite<21|handout:none>{\tuple{4,1}}, \hilite<22|handout:none>{\tuple{4,2}}, \tuple{4,3}\}$}%
        \only<9-11,14-15,19|handout:none>{\alert{$\tuple{4,1}, \tuple{4,2}, \tuple{4,3}\}$}}%
        \only<23|handout:none>{$\tuple{4,1}, \tuple{4,2}, \hilite{\tuple{4,3}}\}$}
        }
     \end{minipage}};

     \node at (-0.5,0.5) {}
      child [line width=0.1pt, level distance=2cm]{node {$w$}
        child {node {$x$}
          child {node {$y$}
            child {node {$z$}
      }}}};

    \node[draw, ellipse, fill=green@AI, inner sep=0pt, minimum
      width=0.8cm, minimum height=0.4cm, text=white] (root) at (6,0) {};

    \visible<2-|handout:1> {
      \node[draw, ellipse, fill=green@AI, inner sep=0pt, minimum
        width=0.8cm, minimum height=0.4cm, text=white] (w1) at (2,-1.5) {\small 1};
      \draw[-stealth] (root) to (w1);
    }

    \visible<3-|handout:1> {
      \node[draw, rectangle, fill=blue@AI, inner sep=0pt, minimum
        width=0.4cm, minimum height=0.4cm, text=white] (y11) at (1,-3.5) {\small 1};
      \draw[-stealth] (w1) to (y11);
    }

    \visible<4-|handout:1> {
      \node[draw, rectangle, fill=blue@AI, inner sep=0pt, minimum
        width=0.4cm, minimum height=0.4cm, text=white] (y12) at (2,-3.5) {\small 2};
      \draw[-stealth] (w1) to (y12);
    }

    \visible<5-|handout:1> {
      \node[draw, rectangle, fill=blue@AI, inner sep=0pt, minimum
        width=0.4cm, minimum height=0.4cm, text=white] (y13) at (3,-3.5) {\small 3};
      \draw[-stealth] (w1) to (y13);
    }

    \visible<6-|handout:1> {
      \node[draw, ellipse, fill=green@AI, inner sep=0pt, minimum
        width=0.8cm, minimum height=0.4cm, text=white] (w2)
      at (9,-1.5) {\small 2};
      \draw[-stealth] (root) to (w2);
    }

    \visible<7-|handout:1> {
      \node[draw, ellipse, fill=green@AI, inner sep=0pt, minimum
        width=0.8cm, minimum height=0.4cm, text=white] (y21)
      at (7,-3.5) {\small 1};
      \draw[-stealth] (w2) to (y21);
    }

    \visible<8-|handout:1> {
      \node[draw, ellipse, fill=green@AI, inner sep=0pt, minimum
        width=0.8cm, minimum height=0.4cm, text=white] (x211)
      at (4,-5.5) {\small 1};
      \draw[-stealth] (y21) to (x211);
    }

    \visible<9-|handout:1> {
      \node[draw, rectangle, fill=blue@AI, inner sep=0pt, minimum
        width=0.4cm, minimum height=0.4cm, text=white] (z2111)
      at (3.4,-7.5) {\small 1};
      \draw[-stealth] (x211) to (z2111);
    }

    \visible<10-|handout:1> {
      \node[draw, rectangle, fill=blue@AI, inner sep=0pt, minimum
        width=0.4cm, minimum height=0.4cm, text=white] (z2112)
      at (4,-7.5) {\small 2};
      \draw[-stealth] (x211) to (z2112);
    }

    \visible<11-|handout:1> {
      \node[draw, rectangle, fill=blue@AI, inner sep=0pt, minimum
        width=0.4cm, minimum height=0.4cm, text=white] (z2113)
      at (4.6,-7.5) {\small 3};
      \draw[-stealth] (x211) to (z2113);
    }

    \visible<12-|handout:1> {
      \node[draw, ellipse, fill=green@AI, inner sep=0pt, minimum
        width=0.8cm, minimum height=0.4cm, text=white] (x212)
      at (6,-5.5) {\small 2};
      \draw[-stealth] (y21) to (x212);
    }

    \visible<13-|handout:1> {
      \node[draw, rectangle, fill=blue@AI, inner sep=0pt, minimum
        width=0.4cm, minimum height=0.4cm, text=white] (z2121)
      at (5.4,-7.5) {\small 1};
      \draw[-stealth] (x212) to (z2121);
    }

    \visible<14-|handout:1> {
      \node[draw, rectangle, fill=blue@AI, inner sep=0pt, minimum
        width=0.4cm, minimum height=0.4cm, text=white] (z2122) at (6,-7.5) {\small 2};
      \draw[-stealth] (x212) to (z2122);
    }

    \visible<15-|handout:1> {
      \node[draw, rectangle, fill=blue@AI, inner sep=0pt, minimum
        width=0.4cm, minimum height=0.4cm, text=white] (z2123)
      at (6.6,-7.5) {\small 3};
      \draw[-stealth] (x212) to (z2123);
    }

    \visible<16-|handout:1> {
      \node[draw, ellipse, fill=green@AI, inner sep=0pt, minimum
        width=0.8cm, minimum height=0.4cm, text=white] (x213)
      at (8,-5.5) {\small 3};
      \draw[-stealth] (y21) to (x213);
    }

    \visible<17-|handout:1> {
      \node[draw, rectangle, fill=blue@AI, inner sep=0pt, minimum
        width=0.4cm, minimum height=0.4cm, text=white] (z2131)
      at (7.4,-7.5) {\small 1};
      \draw[-stealth] (x213) to (z2131);
    }

    \visible<18-|handout:1> {
      \node[draw, rectangle, fill=blue@AI, inner sep=0pt, minimum
        width=0.4cm, minimum height=0.4cm, text=white] (z2132) at (8,-7.5) {\small 2};
      \draw[-stealth] (x213) to (z2132);
    }

    \visible<19-|handout:1> {
      \node[draw, rectangle, fill=blue@AI, inner sep=0pt, minimum
        width=0.4cm, minimum height=0.4cm, text=white] (z2133)
      at (8.6,-7.5) {\small 3};
      \draw[-stealth] (x213) to (z2133);
    }

    \visible<20-|handout:1> {
      \node[draw, ellipse, fill=green@AI, inner sep=0pt, minimum
        width=0.8cm, minimum height=0.4cm, text=white] (x214)
      at (10,-5.5) {\small 4};
      \draw[-stealth] (y21) to (x214);
    }

    \visible<21-|handout:1> {
      \node[draw, rectangle, fill=blue@AI, inner sep=0pt, minimum
        width=0.4cm, minimum height=0.4cm, text=white] (z2141)
      at (9.4,-7.5) {\small 1};
      \draw[-stealth] (x214) to (z2141);
    }

    \visible<22-|handout:1> {
      \node[draw, rectangle, fill=blue@AI, inner sep=0pt, minimum
        width=0.4cm, minimum height=0.4cm, text=white] (z2142) at (10,-7.5) {\small 2};
      \draw[-stealth] (x214) to (z2142);
    }

    \visible<23|handout:1> {
      \node[draw, ellipse, fill=red@AI, inner sep=0pt, minimum
        width=0.8cm, minimum height=0.4cm, text=white, accepting] (z2143)
      at (11,-7.5) {\small 3};
      \draw[-stealth] (x214) to (z2143);
    }
  \end{tikzpicture}
\end{frame}

\else

\begin{frame}
  NOTE: naive backtracking example commented out because it takes
  forever to compile.
\end{frame}
\fi

\begin{frame}{Is This a New Algorithm?}
  We have already seen this algorithm: \\ \alert{Backtracking
    corresponds to depth-first search} (Chapter B8) \\ with the
  following state space:
  \begin{itemize}
  \item \hilite{states:} partial assignments
  \item \hilite{initial state:} empty assignment $\emptyset$
  \item \hilite{goal states:} consistent total assignments
  \item \hilite{actions:} $\op{assign}_{v,d}$ assigns value $d \in
  \dom(v)$ to variable $v$
  \item \hilite{action costs:} all 0 (all solutions are of equal quality)
  \item \hilite{transitions:}
    \begin{itemize}
    \item for each \alert{non-total consistent} assignment $\alpha$, \\choose variable
      $v = \func{select}(\alpha)$ that is unassigned in $\alpha$
    \item transition $\alpha \xrightarrow{\op{assign}_{v,d}} \alpha
      \cup \{v \mapsto d\}$ for each $d \in \dom(v)$
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Why Depth-First Search?}
  Depth-first search is particularly well-suited for CSPs:
  \begin{itemize}
  \item path length \alert{bounded} (by the number of variables)
  \item solutions located at \alert{the same depth} (lowest search
  layer)
  \item state space is directed \alert{tree}, initial state is the
  root \\ $\leadsto$ \alert{no duplicates} (\hilite{Why?})
    %% Assume we had two duplicate nodes $n$, $n'$. Clearly they
    %% cannot be in the same branch of the search tree. Hence,
    %% consider their lowest common ancestor. At that node, let $v$ be
    %% the chosen variable. Since we end up in different branches, we
    %% assign two different values to $v$. Hence, $n$ and $n'$ cannot
    %% have the same partial assignment associated with them.
  \end{itemize}
  Hence none of the problematic cases for depth-first search occurs.
\end{frame}

\begin{frame}{Naive Backtracking: Discussion}
  \begin{itemize}
  \item Naive backtracking often has to exhaustively explore \\
    \alert{similar} search paths (\ie, partial assignments \\ that are
    identical except for a few variables).
  \item ``Critical'' variables are not recognized \\ and hence
    considered for assignment (too) late.
  \item Decisions that necessarily lead to constraint violations
    \\ are only recognized when all variables involved \\ in the
    constraint have been assigned.
  \end{itemize}

  $\leadsto$ more intelligence by \alert{focusing on critical
    decisions} \\ \invisible{$\leadsto$} and by \alert{inference} of
  consequences of previous decisions
\end{frame}

\section{Variable and Value Orders}

\begin{frame}{Naive Backtracking}
  \small
  \begin{block}{\textbf{function} $\func{NaiveBacktracking}(\mathcal{C},
      \alpha)$:}
    $\langle V, \dom, (R_{uv})\rangle := \mathcal{C}$

    \smallskip

    \textbf{if} $\alpha$ is inconsistent with $\mathcal{C}$:\\
    \ind\textbf{return} \textbf{inconsistent}

    \smallskip

    \textbf{if} $\alpha$ is a total assignment:\\
    \ind\textbf{return} $\alpha$

    \smallskip

    select \alert{some variable} $v$ for which $\alpha$ is not
    defined

    \smallskip

    \textbf{for each} $d \in \dom(v)$ \alert{in some order}:\\
    \ind$\alpha' := \alpha \cup \{v \mapsto d\}$\\
    \ind$\alpha'' := \func{NaiveBacktracking}(\mathcal{C},\alpha')$\\
    \ind\textbf{if} $\alpha'' \neq \textbf{inconsistent}$:\\
    \indtwo\textbf{return} $\alpha''$\\
    \textbf{return} \textbf{inconsistent}
  \end{block}
\end{frame}

\begin{frame}{Variable Orders}
  \begin{itemize}
  \item Backtracking does not specify in which order  \\
    \alert{variables} are considered for assignment.
    \item Such orders can strongly influence the search space size \\
    and hence the search performance.  \\
    $\leadsto$ \hilite{example:} exercises
    \item Eventually we have to assign all variables\\
    $\leadsto$ prefer critical assignments (\alert{fail early})
  \end{itemize}
  \hilite{German:} Variablenordnung
\end{frame}


\begin{frame}{Value Orders}
  \begin{itemize}
  \item Backtracking does not specify in which order \\
    the \alert{values} of the selected variable $v$ are considered.
    \item This is not as important because it \alert{does not matter} \\ in
    subtrees without a solution. (\hilite{Why not?})
    \item \alert{If} there is a solution in the subtree, then
    ideally \\ a value that leads to a solution should be chosen. \\
    $\leadsto$ prefer promising assignments
  \end{itemize}
  \hilite{German:} Werteordnung
\end{frame}

\begin{frame}{Static vs.\ Dynamic Orders}
  we distinguish:
  \begin{itemize}
  \item \alert{static} orders (fixed prior to search)
  \item \alert{dynamic} orders (selected variable or value
  order \\ depends on the search state)
  \end{itemize}

  \medskip

  \hilite{comparison:}
  \begin{itemize}
  \item dynamic orders obviously more powerful
  \item static orders $\leadsto$ no computational overhead during
  search
  \end{itemize}

  \medskip

  The following ordering criteria can be used statically, but are more
  effective combined with inference ($\leadsto$ later) and used
  dynamically.
\end{frame}

\begin{frame}{Variable Orders}
  two common variable ordering criteria:
  \begin{itemize}
    \item \alert{minimum remaining values:}\\
      prefer variables that have small \alert{domains}
    \begin{itemize}
      \item \hilite{intuition:} few subtrees $\leadsto$ smaller tree
      \item \hilite{extreme case:} only \alert{one} value $\leadsto$
      forced assignment
    \end{itemize}
    \item \alert{most constraining variable:} \\
      prefer variables contained in \alert{many}
      nontrivial constraints
    \begin{itemize}
      \item \hilite{intuition:} constraints tested early \\
      $\leadsto$ inconsistencies recognized early $\leadsto$ smaller
      tree
    \end{itemize}
  \end{itemize}

  \hilite{combination:} use minimum remaining values criterion, \\
  then most constraining variable criterion to break ties
\end{frame}

\begin{frame}{Value Orders}
  \begin{definition}[conflict]
    Let $\mathcal C = \langle V, \dom, (R_{uv})\rangle$ be a
    constraint network.

    For variables $v \neq v'$ and values $d \in \dom(v)$, $d' \in
    \dom(v')$, \\ the assignment $v \mapsto d$ is \alert{in conflict}
    with $v' \mapsto d'$ if $\langle d, d'\rangle \notin R_{vv'}$.
  \end{definition}

  \medskip

  value ordering criterion for partial assignment $\alpha$ \\ and
  selected variable $v$:
  \begin{itemize}
  \item \alert{minimum conflicts:} prefer values $d \in \dom(v)$
    \\ such that $v \mapsto d$ causes as few conflicts as possible \\
    with variables that are unassigned in $\alpha$
  \end{itemize}
\end{frame}

\section{Summary}

\begin{frame}{Summary: Backtracking}
  basic search algorithm for constraint networks:
  \alert{backtracking}
  \begin{itemize}
    \item extends the (initially empty) partial assignment step by
    step \\ until an \alert{inconsistency} or a \alert{solution} is
    found
    \item is a form of \alert{depth-first search}
    \item depth-first search particularly well-suited \\ because
    state space is directed tree \\ and all solutions at same (known)
    depth
  \end{itemize}
\end{frame}

\begin{frame}{Summary: Variable and Value Orders}
  \begin{itemize}
    \item \alert{Variable orders} influence the performance\\ of
    backtracking significantly.
    \begin{itemize}
      \item goal: \alert{critical} decisions as early as possible
    \end{itemize}
    \item \alert{Value orders} influence the performance  \\ of
    backtracking on \alert{solvable} constraint networks significantly.
    \begin{itemize}
      \item goal: \alert{most promising} assignments first
    \end{itemize}
  \end{itemize}
\end{frame}

\end{document}
